
import sys 
from typing import Dict, List, Iterable, TypeVar, Callable, Generic, Generator
from pathlib import Path 
from rich.tree import Tree
from rich.console import Console 
from itertools import groupby
from functools import reduce

from tree_sitter import Language, Parser, Node
from tree_sitter_language_pack import get_language, get_parser

from ..packages import * 
from .node import TypedNode

JAVA_LANG = get_language('java')
JAVA_PARSER = get_parser('java')

def convert_to_dict(node: Node, lang: Language = JAVA_LANG) -> Dict[str, any]: 
    """Converts a TreeSitter Node into a tree-of-dicts that we use as a lightweight AST 

    This drops certain kinds of Nodes (mostly token-like nodes) and standardizes out the 
    fields that we want to use later.  Since we mostly just wrap this tree-of-dicts into 
    TypedNode objects, it'd probably be easy to just adapt the TypedNode stuff to work 
    directly from the TreeSitter Nodes themselves.

    Args:
        node (Node): a Node generated by TreeSitter

    Returns:
        Dict[str, any]: a reduced AST as a series of nested Dictionaries
    """
    field_id = lang.id_for_node_kind(node.type, True)
    if node.type == ".": 
        return {
            "_type": "dot_access", 
            "_value": node.text.decode("UTF-8"),
            "_start": node.start_byte, 
            "_end": node.end_byte
        }
    elif field_id is None: 
        return None
    elif node.type.endswith('identifier'):
        return {
            "_type": node.type, 
            "_value": node.text.decode("UTF-8"),
            "_start": node.start_byte, 
            "_end": node.end_byte
        }
    elif node.type.endswith("literal"): 
        return {
            "_type": node.type, 
            "_value": node.text.decode("UTF-8"),
            "_start": node.start_byte, 
            "_end": node.end_byte
        }
    
    pairs = [
        x for x in list(convert_to_dict(c, lang) for c in node.children) if x is not None
    ]
    val = node.text.decode("UTF-8") if node.text is not None else None
    if len(pairs) > 0: 
        d = {
            "_type": node.type, 
            "_children": pairs,
            "_start": node.start_byte, 
            "_end": node.end_byte
        }
        if val is not None: 
            d['_value'] = val 
    else: 
        d = { 
             "_type": node.type,
             "_value": node.text.decode("UTF-8"),
            "_start": node.start_byte, 
            "_end": node.end_byte
        }
    return d

def parse_to_node(p: Path): 
    bs = p.read_bytes() 
    parse_tree = JAVA_PARSER.parse(bs) 
    root_node = parse_tree.root_node
    d = convert_to_dict(root_node, JAVA_LANG)
    return TypedNode(d), bs

def construct_class(n: TypedNode, bs: bytes, prefix: str = "class") -> JavaClass: 
    def decode_modifiers(n: Optional[TypedNode]) -> Tuple[List[str], List[JavaAnnotation]]: 
        modifiers: List[str] = [] 
        annotations: List[TypedNode] = [] 
        if n is not None: 
            anns = n.annotation
            for ann in anns: 
                annotation_name = ann.identifier.value 
                args = [] 
                arg_list = ann.annotation_argument_list.children
                for arg in arg_list: 
                    args.append(arg.value)
                annotations.append(JavaAnnotation(annotation_name, args))
            byte_start = max([n.offset_start, *[a.offset_end+1 for a in anns]])
            byte_end = n.offset_end
            mod_str = bs[byte_start:byte_end].decode("UTF-8")
            modifiers = mod_str.strip().split(' ')
        return modifiers, annotations
        
    def construct_method(n: TypedNode) -> JavaMethod: 
        #console = Console() 
        #console.print(n.astree())
        name = n.get('identifier').value 
        type_identifier = n.find('type_identifier') 
        generic_type = n.find('generic_type') 
        other_type = n.find('_type')
        if len(type_identifier) > 0: 
            type = type_identifier.value 
        elif len(generic_type) > 0: 
            type = generic_type.get_text(bs)
        else: 
            type = other_type.value 
        param_tuples = [
            (x.get('identifier').value, x.find('type').value) 
            for x in n.formal_parameters.formal_parameter
        ]
        modifiers, annotations = decode_modifiers(n.modifiers.first())
        params = [JavaParameter(name, type) for (name, type) in param_tuples]
        m = JavaMethod(name, type, params, modifiers=modifiers, annotations=annotations)
        return m
        
    def construct_field(n: TypedNode) -> JavaField: 
        #console = Console() 
        #console.print(n.astree())
        type_str = n.find('type')[0].get_text(bs) 
        field_name = n.variable_declarator.identifier[0].value 
        modifiers, annotations = decode_modifiers(n.modifiers.first())
        return JavaField(field_name, type_str, modifiers=modifiers, annotations=annotations)

    name = n.identifier.value
    kind = JavaClassKind(prefix) 
    class_body = n.find(f"{prefix}_body")

    #Console().print(n.modifiers.first().astree())
    modifiers, annotations = decode_modifiers(n.modifiers.first())

    fields: List[JavaField] = [construct_field(f) for f in class_body.field_declaration]
    methods: List[JavaMethod] = [construct_method(m) for m in class_body.method_declaration]
    classes: List[JavaClass] = [construct_class(c, bs) for c in class_body.class_declaration] 

    type_identifiers: Set[str] = set([ti.value for ti in n.search('type_identifier')])
    type_identifiers.update([a.name for a in annotations])
    
    type_identifiers.update([
        field_access.children[0].value
        for ann in n.search('annotation') 
        for evp in ann.search('element_value_pair')
        for field_access in evp.children[1].search('field_access')
    ])
    
    field_dict = { f.name: f for f in fields }  
    method_dict = { m.name: m for m in methods }
    class_dict = { c.name: c for c in classes } 

    return JavaClass(
        name=name, 
        kind=kind, 
        fields=field_dict, 
        methods=method_dict, 
        classes=class_dict,
        modifiers=modifiers,
        annotations=annotations,
        type_identifiers=type_identifiers
    ) 
    

def examine(p: Path, root: Package) -> ClassFile: 
    node, bs = parse_to_node(p) 
    pkg_name: List[str] = node.package.identifier.value.split('.')
    pkg = root.get_package(pkg_name)

    name: str = p.name
    import_packages = [x.identifier.value.split(".") for x in node.import_declaration]
    imports = [(['.'.join(x[:-1]), x[-1]]) for x in import_packages]

    classes = [construct_class(c, bs, "class") for c in node.class_declaration]
    interfaces = [construct_class(c, bs, "interface") for c in node.interface_declaration]
    enums = [construct_class(c, bs, "enum") for c in node.enum_declaration]
    
    cf: ClassFile = ClassFile(
        pkg, 
        p, 
        name, 
        imports=imports, 
        classes={
            jc.name: jc for jc in ( classes + interfaces + enums ) 
        }
    )
    pkg.class_files[name] = cf 
    return cf

if __name__ == '__main__': 
    node, bs = parse_to_node(Path(sys.argv[-1]))
    tree = node.astree()
    console = Console() 
    console.print(tree) 
    